{
    "componentChunkName": "component---src-pages-markdown-remark-frontmatter-slug-js",
    "path": "/post/4/",
    "result": {"data":{"markdownRemark":{"html":"<h1>Big-O 표기법이란?</h1>\n<blockquote>\n<p><strong>점근 표기법</strong>(asymptotic notation)</p>\n<p>점근 표기법은 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법입니다. **알고리즘의 복잡도를 단순화(도식화)**할 때나 무한급수의 뒷부분을 간소화할 때 쓰입니다. <a href=\"https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95\">(위키백과)</a></p>\n</blockquote>\n<p><em>Big O 표기법</em> 은 대표적인 점근 표기법중 하나로 어떠한 알고리즘이 <strong>최악</strong>의 경우를 기준으로 어느정도의 효율성을 보일 것인가를 예측하는 표기법입니다. 어떤 알고리즘을 f(n)이라 하고, 이를 Big-O 표기법으로 표현하면 O(f(n))으로 표현됩니다.</p>\n<h3>Big-O 복잡도</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1644335aaa8832500767fc4dac43ca78/11a8f/post-4-big-o.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+ElEQVQ4y3WT7bKaMBCGvf+b6h+np9MO2joc7QH0WAREISQkkA+SbDoKAtppZicD2Tz77u5sFqdTQinDmBBSj1ZV+HzO8/ySZVmapteiqGs6ejEmlLI0yxZVVTnnAMDNltb6IxjWZrO5XK/zO/1HXdMFQqj/BxhORYna/GKUmse7ewez9uYhpB5gSqm1tr/HjnHxc6OFeAR9SmpUJvUDDoJAKdX7DOcSk0HuFZvCTXAYhiOsCBVF+W8j/qv8BNdUlGiuPAbBjfq80FZ2Q80YY8bYbrfrum4Gl4MEDKTsbIp4SWVatU9w0zTb3XaCCZEYj+lZgJKKDLeyM69pY0ziOPZ9X2vd+5oktXoI1EidIE74A3uBy1uGEARTzSw5OwBt7Rm3OeHGaue4NbW1tTVEyVTJ3AEn45CMsGaM559U4jNKmzZ3DoGpwDIHrQMOhmmZKZkAtBP8EQRctM6xPFhF8bFkGJwGd9M3YA2AAdebstZOad9hP9ykbOf//uFv31NRIVVd+PXCr1cx7L0VothWWyzw0O17zc77/sVbfkuCk+6UErJTndXGGqs7rZVWQt2MS6PNS8Nuyqfj0V//ik9/oig6HA7r9frr29tyuVytPM/zoija7/dhGI6vaOo2AAyv4jFJTdMihMoSNU2jVDcfTGOM1hoAMMZ/ASjYzttl2MGBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Big_O_Notation\"\n        title=\"Big_O_Notation\"\n        src=\"/static/1644335aaa8832500767fc4dac43ca78/5a190/post-4-big-o.png\"\n        srcset=\"/static/1644335aaa8832500767fc4dac43ca78/772e8/post-4-big-o.png 200w,\n/static/1644335aaa8832500767fc4dac43ca78/e17e5/post-4-big-o.png 400w,\n/static/1644335aaa8832500767fc4dac43ca78/5a190/post-4-big-o.png 800w,\n/static/1644335aaa8832500767fc4dac43ca78/c1b63/post-4-big-o.png 1200w,\n/static/1644335aaa8832500767fc4dac43ca78/11a8f/post-4-big-o.png 1272w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Big O 로 정의하는 복잡성에는 두가지가 존재합니다.</p>\n<ul>\n<li>시간 복잡도</li>\n<li>공간 복잡도</li>\n</ul>\n<p>시간 복잡도는 대부분의 경우 어떤 알고리즘이 <strong>최악</strong>의 경우 실행 시간이 어떻게 분포될지를 나타냅니다. 하지만 실행 시간 그 자체를 계산하는 것이 아니라, <strong>연산이 몇 번 이루어지는 가</strong>를 계산합니다. 거의 대부분의 경우 실행 시간과 비례합니다.</p>\n<p>공간 복잡도는 프로그램을 실행시킨 후 그 프로그램이 종료될 때 까지 필요로 하는 자원 공간을 계산합니다. 즉 <strong>메모리 효율</strong>을 계산하는 것이라 생각하면 편합니다.</p>\n<p>이 글에서는 비교적 자주 쓰이는 시간 복잡도에 대해서만 서술했습니다.</p>\n<p>O(1) ⇒ O(n) ⇒ O(n²) ⇒ O(log n) 순서로 예시를 작성했습니다.</p>\n<h2>일반적인 예시</h2>\n<h3>O(1)</h3>\n<pre><code class=\"language-javascript\">function example1(n) {\r\n  return n + n;\r\n}\n</code></pre>\n<p><em>example1</em> 은 입력이 1개이며 n의 값에 무관하게 한 번의 연산만 진행합니다. 상수 시간이라고 합니다.</p>\n<h3>O(n)</h3>\n<pre><code class=\"language-javascript\">function example2(n) {\r\n  for (let i = 0; i &#x3C; n; i++) {\r\n    console.log(i);\r\n  }\r\n}\n</code></pre>\n<p><em>example2</em> 는 입력 n번만큼 반복하여 연산합니다. 선형 시간, 혹은 직선적 시간이라고 합니다.</p>\n<h3>O(n²)</h3>\n<pre><code class=\"language-javascript\">function example3(n) {\r\n  for (let i = 0; i &#x3C; n; i++) {\r\n    console.log(i);\r\n    for (let j = 0; j &#x3C; n; j++) {\r\n      console.log(j);\r\n    }\r\n  }\r\n}\n</code></pre>\n<p><em>example3</em> 는 입력 n의 제곱만큼 연산합니다. 2차 시간이라고 합니다.</p>\n<h3><em>번외</em> : O(n³)</h3>\n<pre><code class=\"language-javascript\">function example4(n) {\r\n  for (let i = 0; i &#x3C; n; i++) {\r\n    console.log(i);\r\n    for (let j = 0; j &#x3C; n; j++) {\r\n      console.log(j);\r\n      for (let k = 0; k &#x3C; n; k++) {\r\n        console.log(k);\r\n      }\r\n    }\r\n  }\r\n}\n</code></pre>\n<p><em>example4</em> 는 O(n³), 3차 시간 복잡도의 예</p>\n<h3>O(log n)</h3>\n<pre><code class=\"language-javascript\">function example5(n) {\r\n  for (let i = 0; i &#x3C; n; i * 2) {\r\n    console.log(i);\r\n  }\r\n}\n</code></pre>\n<p><em>example5</em> 는 2의 2승(2²)부터 n승까지의 항목을 출력하는 함수입니다. Big-O 표기법은 <strong>최악</strong>의 경우를 기준으로 한다는 점을 상기해보면, n 입력 값이 천만이라 가정해도 log₂(10,000,000)은 23.253... 이기 때문에 23번만 값을 출력합니다.</p>\n<h2>Big-O 표기법 규칙</h2>\n<p>개발할 때 위와같은 간단한 반복문만 사용하지는 않습니다. Big-O 표기법에는 더 복잡한 구조의 알고리즘의 시간 복잡도를 계산할 수 있도록 돕는 규칙이 있습니다. 여러가지 규칙이 있지만 이글에선 자주 사용되는 4가지 법칙만 살펴보겠습니다.</p>\n<ul>\n<li><strong>계수 법칙</strong> : 상수 제거하기</li>\n<li><strong>합의 법칙</strong> : 빅오 더하기</li>\n<li><strong>곱의 법칙</strong> : 빅오 곱하기</li>\n<li><strong>다항 법칙</strong> : 빅오의 k승</li>\n</ul>\n<h3>계수 법칙 <em>상수 제거하기</em></h3>\n<p>Big-O 표기법에선 <strong>입력 크기와 연관되지 않은 상수를 무시</strong>합니다.</p>\n<pre><code class=\"language-javascript\">function example6(n) {\r\n  let count = 0;\r\n  for (let i = 0; i &#x3C; n; i++) {\r\n    count += i;\r\n  }\r\n  count *= 100; // 1번 지점\r\n  count /= 100; // 2번 지점\r\n  return count;\r\n}\n</code></pre>\n<p><em>example6</em> 는 n번만큼 반복한 후 추가로 곱하기(*) 연산과 나누기(/) 연산을 합니다. 여기서 마지막 두번의 연산(1,2번 지점)이 위에서 언급한 <em>상수</em> 가 됩니다. 1, 2번 지점의 코드가 없다면 <em>example6</em> 는 <em>f(n) = n</em> 으로 표현할 수 있습니다. 1, 2번 지점의 코드를 포함한다면 <em>example6</em> 는 <em>f(n) = n + 2</em> 로 표현됩니다. 하지만 계수 법칙에 따라 상수를 제거(혹은 제외)함으로 Big-O 표기법으로 표현하면 O(n)이 됩니다.</p>\n<p>이 법칙은 곱셈에서도 유효합니다.</p>\n<pre><code class=\"language-javascript\">function example7(n) {\r\n  let count = 0;\r\n  for( let i = 0; &#x3C; n * 10; i++ ) {\r\n    count += i;\r\n  }\r\n  return count;\r\n}\n</code></pre>\n<p><em>example7</em> 은 n * 10번 반복하여 연산합니다. 10배라면 꽤 큰 숫자로 보입니다. 하지만 Big-O 표기법은 <strong>최악</strong>의 경우를 기준으로 한다는 점을 기억해야 합니다. n을 무한대 또는 아주 큰 수라고 생각하면 10배로 연산한다고 해서 크게 달라지는 점은 없습니다. Big-O 표기법은 n(입력값)에 비례하여 알고리즘이 어느정도의 효율성을 보이느냐를 따지는 지표이므로 이와같은 상수는 큰 영향을 주지 못합니다.</p>\n<h3>합의 법칙 <em>빅오 더하기</em></h3>\n<p>합의 법칙은 <strong>시간 복잡도를 더할 수 있다</strong>는 것입니다. 두개 이상의 여러 알고리즘을 보유한 상위의 알고리즘이 있고, 이 알고리즘을 Big-O 표기법으로 표현하고 싶을 경우가 있습니다. 합의 법칙은 이런 경우에 적용할 수 있습니다.</p>\n<pre><code class=\"language-javascript\">function example8(n) {\r\n  for (let i = 0; i &#x3C; n; i++) {\r\n    // 1번 지점\r\n    console.log(i);\r\n  }\r\n  for (let j = 0; j &#x3C; n * 2; j++) {\r\n    // 2번 지점\r\n    console.log(j);\r\n  }\r\n}\n</code></pre>\n<p>1번 지점은 n번만큼 반복하여 <em>f(n) = n</em> 입니다. 2번 지점은 n * 2번 반복하여 <em>f(n) = 2n</em> 입니다. 이를 합하게 되면 <em>f(n) = 6n</em> 이 됩니다. 이제 여기에 계수 법칙을 적용하게 되면 <em>O(n) = n</em> 으로 표현할 수 있습니다.</p>\n<h3>곱의 법칙 <em>빅오 곱하기</em></h3>\n<p>곱의 법칙은 합의 법칙과 마찬가지로 <strong>시간 복잡도를 곱할 수 있다</strong>는 것입니다.</p>\n<pre><code class=\"language-javascript\">function example9(n) {\r\n  let count = 0;\r\n  for (let i = 0; i &#x3C; n; i++) {\r\n    ++count;\r\n    for (let j = 0; j &#x3C; 2 * n; j++) {\r\n      ++count;\r\n    }\r\n  }\r\n  return count;\r\n}\n</code></pre>\n<p><em>example9</em> 함수는 <em>f(n) = n * 2n</em> 입니다. 수식에 따라 시간 복잡도를 곱하게 되면 <em>f(n) = 2n²</em> 가 되고, 여기에 계수 법칙을 적용하면 최종적으로 <em>O(n) = n²</em> 로 표현할 수 있습니다.</p>\n<h3>다항 법칙 <em>빅오의 k승</em></h3>\n<p>다항 법칙은 곱의 법칙과 비슷한 맥락으로 이해할 수 있습니다. 시간 복잡도가 여러개의 항(다항)을 가지고 있을 때 동일한 다항 차수를 지닌 빅오 표기법을 지님을 나타냅니다.</p>\n<pre><code class=\"language-javascript\">function example10(n) {\r\n  let count = 0;\r\n  for (let i = 0; i &#x3C; n * n; i++) {\r\n    ++count;\r\n  }\r\n  return count;\r\n}\n</code></pre>\n<p><em>example10</em> 함수에서 <em>f(n) = n * n = n²</em> 입니다.</p>","frontmatter":{"date":"May 02, 2021","slug":"post/4","title":"Big-O 표기법 (Big-O Notation)","summary":"Big O 표기법은 대표적인 점근 표기법중 하나로 어떠한 알고리즘이 최악의 경우를 기준으로 어느정도의 효율성을 보일 것인가를 예측하는 표기법입니다.","categories":["Algorithm"],"featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/1644335aaa8832500767fc4dac43ca78/1e010/post-4-big-o.png","srcSet":"/static/1644335aaa8832500767fc4dac43ca78/7a5b8/post-4-big-o.png 28w,\n/static/1644335aaa8832500767fc4dac43ca78/4c483/post-4-big-o.png 55w,\n/static/1644335aaa8832500767fc4dac43ca78/1e010/post-4-big-o.png 110w,\n/static/1644335aaa8832500767fc4dac43ca78/43be6/post-4-big-o.png 220w","sizes":"(min-width: 110px) 110px, 100vw"},"sources":[{"srcSet":"/static/1644335aaa8832500767fc4dac43ca78/629a0/post-4-big-o.webp 28w,\n/static/1644335aaa8832500767fc4dac43ca78/938d3/post-4-big-o.webp 55w,\n/static/1644335aaa8832500767fc4dac43ca78/8c6ff/post-4-big-o.webp 110w,\n/static/1644335aaa8832500767fc4dac43ca78/4c27b/post-4-big-o.webp 220w","type":"image/webp","sizes":"(min-width: 110px) 110px, 100vw"}]},"width":110,"height":110}}}}},"allMarkdownRemark":{"edges":[{"node":{"id":"34a4798d-64e7-5122-bd17-24ca20054faa","frontmatter":{"slug":"post/6","categories":["Algorithm","Java"]}}},{"node":{"id":"4a604184-bb0f-575c-979e-a7785f18c62b","frontmatter":{"slug":"post/5","categories":["Algorithm","Java"]}}},{"node":{"id":"7e9ff073-14a6-5b47-8908-33cc3e702baf","frontmatter":{"slug":"post/4","categories":["Algorithm"]}}},{"node":{"id":"3c3aef0f-8477-52a1-a098-18b992666a28","frontmatter":{"slug":"post/3","categories":["Javascript"]}}},{"node":{"id":"6b375d7d-60df-5b11-9328-35edb730acf5","frontmatter":{"slug":"post/2","categories":["React"]}}},{"node":{"id":"ac36c884-43da-5aec-b185-c96d412349cc","frontmatter":{"slug":"post/1","categories":["Javascript"]}}}]}},"pageContext":{"id":"7e9ff073-14a6-5b47-8908-33cc3e702baf","frontmatter__slug":"post/4","__params":{"frontmatter__slug":"post"}}},
    "staticQueryHashes": ["2721053520"]}