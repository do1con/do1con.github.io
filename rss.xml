<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[do1con blog RSS]]></title><description><![CDATA[do1con의 개발 블로그입니다.]]></description><link>https://do1con.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 10 Nov 2021 11:59:33 GMT</lastBuildDate><item><title><![CDATA[Java - BufferedReader 사용법, Scanner와의 차이]]></title><description><![CDATA[알고리즘 문제를 풀때 BufferedReader와 BufferedWriter를 어떻게 활용할 수 있는지 정리한 글입니다. 본론에 앞서, BufferedReader와 BufferedWriter…]]></description><link>https://do1con.github.io/post-6-buffered_reader_buffered_writer/</link><guid isPermaLink="false">https://do1con.github.io/post-6-buffered_reader_buffered_writer/</guid><pubDate>Wed, 10 Nov 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;알고리즘 문제를 풀때&lt;/strong&gt; BufferedReader와 BufferedWriter를 어떻게 활용할 수 있는지 정리한 글입니다.&lt;/p&gt;
&lt;p&gt;본론에 앞서, BufferedReader와 BufferedWriter가 왜 빠른지에 대해서 언급을 하는게 순서상 옳지만, 관련 내용은 &lt;strong&gt;아주&lt;/strong&gt;간단하게만 짚고 넘어가겠습니다.&lt;/p&gt;
&lt;p&gt;이것을 자세히 설명하려면 자바가 문자열을 어떻게 다루는지(문자열 인코딩을 어떻게 처리하는가)에 대한 내용이 필요한데, 글을 따로 써야할 정도로 내용이 길기도 하고 저도 그걸 설명할 만큼 자바에 대한 지식이 충분하지 않기 때문이기도 합니다. (즉 잘 모른다는 소리입니다 ^^;)&lt;/p&gt;
&lt;h2&gt;Scanner와 BufferedReader의 차이&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scanner: 사용자가 입력한 데이터를 토큰단위로 자른 후 특정 형태로 &apos;&lt;strong&gt;parse&apos;&lt;/strong&gt;&apos;합니다.&lt;/li&gt;
&lt;li&gt;BufferedReader: 사용자가 입력한 데이터를 String형태 그대로 (개행 전까지)덩어리째 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scanner는 자바책에서 가장 먼저 알려주는 입력 객체인 만큼, 사용법이 간단합니다.
입력한 대로 토큰을 자르고, 원하는 형태로 parse시켜줍니다. (int, double 등등) 데이터를 그때 그때 읽어들이는데, space, enter를 경계로 인식합니다. 자체적인 예외처리과정이 있습니다.&lt;/p&gt;
&lt;p&gt;그에 반해 BufferedReader는 토큰형태로 자르지 않고, 버퍼에 데이터가 가득 차거나 개행되기 전까지 입력을 계속 받습니다. 그리고 그 덩어리 째로(String) 데이터를 사용하게 됩니다. 예외처리를 직접 작성해야합니다. (IOException)&lt;/p&gt;
&lt;p&gt;Scanner와 BufferedReader 둘 다 버퍼를 사용합니다. 심지어 버퍼의 크기는 BufferedReader가 훨씬 큽니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Scanner: 1KB, BufferdReader: 8KB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;하지만 Scanner는 &apos;그때 그때&apos; 계속해서 토큰단위로 잘라서 데이터를 처리하고, BufferdReader는 버퍼에 모아서 한번에 처리한다는 차이가 있습니다. &apos;작은 일을 여러번 하기&apos;냐 &apos;모아서 한번에 처리하기&apos;냐의 차이로 볼 수도 있을 것 같습니다.&lt;/p&gt;
&lt;p&gt;Scanner는 데이터를 자르고, 특정 형태로 파싱하느라 바쁜데 BufferedReader는 모았다가 아무것도 하지 않고 그대로 전달해주니까요.&lt;/p&gt;
&lt;p&gt;처리하는 데이터가 작은 경우엔 큰 차이가 없을 수 있다고 합니다. 하지만 보통은 BufferedReader가 빠르다는게 정론이라고 합니다.&lt;/p&gt;
&lt;h2&gt;BufferedReader 사용법&lt;/h2&gt;
&lt;p&gt;BufferdReader에 대한 모든 것은 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html&quot;&gt;이곳&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;
&lt;p&gt;이 글에선 자주 사용하는 메소드, 사용법만 살펴보겠습니다.&lt;/p&gt;
&lt;p&gt;BufferedReader를 사용할 땐 보통 InputStreamReader를 사용합니다.
InputStreamReader는 byte stream을 character stream으로 변경해줍니다.
InputStreamReader를 통해 한 글자 한 글자 BufferedReader가 버퍼에 쌓아간다고 생각해도 될 것같습니다.&lt;/p&gt;
&lt;p&gt;BufferedReader의 리더에는 꼭 InputStreamReader가 쓰일 필요는 없다곤 합니다만 보통은 InputStreamReader를 사용합니다.&lt;/p&gt;
&lt;h2&gt;String을 쪼개기 위한 StringTokenizer 활용&lt;/h2&gt;
&lt;p&gt;BufferedReader는 &lt;strong&gt;무조건 한 줄씩&lt;/strong&gt;읽는 다는 것을 기억해야합니다.
때문에 내용물을 어떻게 가공할지에 대해선 저희가 코드로 작성해주어야 합니다.
이에 자주 사용하는 방법인 StringTokenizer의 활용 예제를 적어보겠습니다. (사실 &lt;a href=&quot;post/post-5&quot;&gt;저번 글&lt;/a&gt;에 적은 코드와 거의 같습니다.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

	public static void main(String[] args) throws IOException {
    // BufferedReader를 사용할땐 throws IOException를 해주거나 try/catch로 감싸줘야 함.

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int a = Integer.parseInt(st.nextToken());

		System.out.println(a);

    br.close();

	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이코드에서 중요한 요소는 세가지입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;예외처리를 반드시 해주어야 한다.(throws IOException / try catch)&lt;/li&gt;
&lt;li&gt;형 변환은 직접 처리해준다.&lt;/li&gt;
&lt;li&gt;입력 작업이 끝난 후 close()를 통해 입력 스트림을 닫아준다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 세가지 중요한 점만 유념한다면, BufferedReader를 사용해보며 이것저것 실험해보기에도 문제는 없을 듯 합니다.&lt;/p&gt;
&lt;p&gt;다음 Java에 대한 글은 BufferedWriter가 될 것 같습니다.&lt;/p&gt;
&lt;p&gt;지적, 조언은 감사하게 받고 있습니다. 잘못된 점이 있다면 댓글로 남겨주세요.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Java로 알고리즘문제를 풀때, Scanner 대신 BufferedReader를 사용해보자]]></title><description><![CDATA[블로그의 형태를 어느정도 잡아둔 후, 저는 예정대로 백준에서 알고리즘 문제를 풀기로 했습니다. 개발자가 되고싶다는 사람이 알고리즘을 소홀히 했다는 죄책감도 있고, 요즘은 코딩테스트가 필수이기도 하니까요. 저는 그나마 배운적 있는 언어인 C와 Java…]]></description><link>https://do1con.github.io/post-5-scanner_vs_buffered_reader/</link><guid isPermaLink="false">https://do1con.github.io/post-5-scanner_vs_buffered_reader/</guid><pubDate>Mon, 08 Nov 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;블로그의 형태를 어느정도 잡아둔 후, 저는 예정대로 &lt;a href=&quot;https://www.acmicpc.net/&quot;&gt;백준&lt;/a&gt;에서 알고리즘 문제를 풀기로 했습니다. 개발자가 되고싶다는 사람이 알고리즘을 소홀히 했다는 죄책감도 있고, 요즘은 코딩테스트가 필수이기도 하니까요.&lt;/p&gt;
&lt;p&gt;저는 그나마 배운적 있는 언어인 C와 Java중 Java를 선택했습니다. 그리고 호기롭게 &apos;단계별로 풀어보기&apos;에 도전했죠.&lt;/p&gt;
&lt;p&gt;&apos;단계별&apos;이라는 말에 걸맞게 처음 마주한 문제들은 수월히 풀어나갔습니다. 문법을 제대로 이해했는지를 묻는 문제가 다수였습니다.&lt;/p&gt;
&lt;p&gt;그렇게 몇 문제를 풀어나가던 도중, 저는 뭔가 이상함을 느꼈습니다.&lt;/p&gt;
&lt;h2&gt;왜 나만 느리지?&lt;/h2&gt;
&lt;p&gt;다른 좋은 답안들을 참고하려했는데, 메모리나 속도의 차이가 너무 심했습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/a8ca1c8a564ff6acc7c3d019bd8c842f/post-5-1.png&quot; alt=&quot;다른_답들&quot;&gt;
&lt;em&gt;다른 분들의 답&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/b1e6d1c827ffd98feb7e4c56854652b2/post-5-2.png&quot; alt=&quot;나의_답&quot;&gt;
&lt;em&gt;제가 제출한 답&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;다른 문제들도 마찬가지였습니다.
메모리와 시간에서 2배에서 3배정도까지 차이가 났습니다.&lt;/p&gt;
&lt;p&gt;저는 어떤차이가 있는지 궁금해서 결국 다른분들의 답안을 확인해봤습니다.&lt;/p&gt;
&lt;h2&gt;아무도 Scanner를 사용하지 않는다.&lt;/h2&gt;
&lt;p&gt;상위권에 계신 많은분들의 답을 확인해본 결과, 눈에 띄는 큰 차이가 있었습니다. 그것은 아무도 Scanner나 System.out.print~를 사용하지 않는다는 것이었습니다.&lt;/p&gt;
&lt;p&gt;그 대신 BufferedReader, InputStreamReader를 import하는 코드가 압도적으로 많았습니다.&lt;/p&gt;
&lt;h2&gt;속도 차이가 얼마나 나는걸까?&lt;/h2&gt;
&lt;p&gt;저는 이것만으로 그렇게 큰 차이가 날 수 있는 것인지 의문이 들었습니다. 하지만 어떤 답안을 들여다 봐도 Scanner의 메소드를 사용하는 답안을 찾을 수 없었습니다. 때문에 저는 이것이 얼마나 큰 차이를 만들어내는지 궁금했습니다.&lt;/p&gt;
&lt;p&gt;그러던 와중 &lt;a href=&quot;https://www.acmicpc.net/blog/view/56&quot;&gt;입력 속도 비교&lt;/a&gt; 글을 발견했습니다.&lt;/p&gt;
&lt;p&gt;글 내용에 따르면, BufferedReader의 속도는 C++이나 C에 비견될 만큼 빠르지만, Scanner는 Python과 비슷한 정도로 느리다고 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2135a1a63538e4c068bc42e5b5686e6d/post-5-3.png&quot; alt=&quot;입력_속도_비교&quot;&gt;&lt;/p&gt;
&lt;p&gt;차이가 이렇게 심하다고 하니 또 궁금해졌습니다.&lt;/p&gt;
&lt;p&gt;제가 제출한 코드에 Scanner가 아닌 BufferedReader를 사용하면 속도가 얼마나 빨라질지 말이죠. 그래서 바로 적용해보기로 했습니다.&lt;/p&gt;
&lt;p&gt;순수하게 Scanner와 BufferedReader의 차이만을 확인하기 위해, 최대한 간단한 문제를 골랐습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1000&quot;&gt;백준 1000번 문제&lt;/a&gt;입니다.&lt;/p&gt;
&lt;p&gt;문제는 간단합니다. A와 B를 입력받은 후 A+B를 출력하는 것입니다.&lt;/p&gt;
&lt;p&gt;우선 원래하던 방식대로 Scanner를 활용해서 문제를 풀어보았습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		Scanner scanner = new Scanner(System.in);

		short a = scanner.nextShort();
		short b = scanner.nextShort();

		System.out.println(a + b);

	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;결과는 이렇습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/829e1b8147b9d8c9ede179705d11e035/post-5-4.png&quot; alt=&quot;scanner결과&quot;&gt;&lt;/p&gt;
&lt;p&gt;그리고 BufferedRedaer를 사용해서 한번 더 풀어보았습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		short a = Short.parseShort(st.nextToken());
		short b = Short.parseShort(st.nextToken());

		System.out.println(a + b);

	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;BufferedReader외에 많은것들이 import되고 사용되었는데, 이에 대해선 다음 포스트에서 설명하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그 결과는 이렇습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/f7d3669c1cf337baabedb46da61faaf3/post-5-5.png&quot; alt=&quot;bufferedReader결과&quot;&gt;&lt;/p&gt;
&lt;p&gt;엄청난 차이는 아니지만 확실히 차이가 있네요. 코드도 더 길어졌는데 말이죠. 상위권 답안도 살펴보았는데 메모리는 큰 차이가 안났지만 시간이 68~70ms로 제 답안과 큰 차이가 났었습니다.&lt;/p&gt;
&lt;p&gt;그 답안들도 살펴보았는데 문제가 워낙 단순하다보니 StringTokenizer를 사용하지 않고 split 한다던가, System.in.read를 사용하는 방식으로 속도를 높힌 코드들이었습니다.&lt;/p&gt;
&lt;p&gt;저는 그정도까지 극단의 효율을 추구할 생각은 없기 때문에 이정도에서 만족하기로 했습니다.&lt;/p&gt;
&lt;p&gt;다음 시간에는 BufferedReader의 사용법을 게시하겠습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Big-O 표기법 (Big-O Notation)]]></title><description><![CDATA[Big-O 표기법이란? 점근 표기법(asymptotic notation…]]></description><link>https://do1con.github.io/post-4-big-o-notation/</link><guid isPermaLink="false">https://do1con.github.io/post-4-big-o-notation/</guid><pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Big-O 표기법이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;점근 표기법&lt;/strong&gt;(asymptotic notation)&lt;/p&gt;
&lt;p&gt;점근 표기법은 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법입니다. **알고리즘의 복잡도를 단순화(도식화)**할 때나 무한급수의 뒷부분을 간소화할 때 쓰입니다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95&quot;&gt;(위키백과)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Big O 표기법&lt;/em&gt; 은 대표적인 점근 표기법중 하나로 어떠한 알고리즘이 &lt;strong&gt;최악&lt;/strong&gt;의 경우를 기준으로 어느정도의 효율성을 보일 것인가를 예측하는 표기법입니다. 어떤 알고리즘을 f(n)이라 하고, 이를 Big-O 표기법으로 표현하면 O(f(n))으로 표현됩니다.&lt;/p&gt;
&lt;h3&gt;Big-O 복잡도&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1644335aaa8832500767fc4dac43ca78/11a8f/post-4-big-o.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 86.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+ElEQVQ4y3WT7bKaMBCGvf+b6h+np9MO2joc7QH0WAREISQkkA+SbDoKAtppZicD2Tz77u5sFqdTQinDmBBSj1ZV+HzO8/ySZVmapteiqGs6ejEmlLI0yxZVVTnnAMDNltb6IxjWZrO5XK/zO/1HXdMFQqj/BxhORYna/GKUmse7ewez9uYhpB5gSqm1tr/HjnHxc6OFeAR9SmpUJvUDDoJAKdX7DOcSk0HuFZvCTXAYhiOsCBVF+W8j/qv8BNdUlGiuPAbBjfq80FZ2Q80YY8bYbrfrum4Gl4MEDKTsbIp4SWVatU9w0zTb3XaCCZEYj+lZgJKKDLeyM69pY0ziOPZ9X2vd+5oktXoI1EidIE74A3uBy1uGEARTzSw5OwBt7Rm3OeHGaue4NbW1tTVEyVTJ3AEn45CMsGaM559U4jNKmzZ3DoGpwDIHrQMOhmmZKZkAtBP8EQRctM6xPFhF8bFkGJwGd9M3YA2AAdebstZOad9hP9ykbOf//uFv31NRIVVd+PXCr1cx7L0VothWWyzw0O17zc77/sVbfkuCk+6UErJTndXGGqs7rZVWQt2MS6PNS8Nuyqfj0V//ik9/oig6HA7r9frr29tyuVytPM/zoija7/dhGI6vaOo2AAyv4jFJTdMihMoSNU2jVDcfTGOM1hoAMMZ/ASjYzttl2MGBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Big_O_Notation&quot;
        title=&quot;Big_O_Notation&quot;
        src=&quot;/static/1644335aaa8832500767fc4dac43ca78/5a190/post-4-big-o.png&quot;
        srcset=&quot;/static/1644335aaa8832500767fc4dac43ca78/772e8/post-4-big-o.png 200w,
/static/1644335aaa8832500767fc4dac43ca78/e17e5/post-4-big-o.png 400w,
/static/1644335aaa8832500767fc4dac43ca78/5a190/post-4-big-o.png 800w,
/static/1644335aaa8832500767fc4dac43ca78/c1b63/post-4-big-o.png 1200w,
/static/1644335aaa8832500767fc4dac43ca78/11a8f/post-4-big-o.png 1272w&quot;
        sizes=&quot;(max-width: 800px) 100vw, 800px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Big O 로 정의하는 복잡성에는 두가지가 존재합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도&lt;/li&gt;
&lt;li&gt;공간 복잡도&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;시간 복잡도는 대부분의 경우 어떤 알고리즘이 &lt;strong&gt;최악&lt;/strong&gt;의 경우 실행 시간이 어떻게 분포될지를 나타냅니다. 하지만 실행 시간 그 자체를 계산하는 것이 아니라, &lt;strong&gt;연산이 몇 번 이루어지는 가&lt;/strong&gt;를 계산합니다. 거의 대부분의 경우 실행 시간과 비례합니다.&lt;/p&gt;
&lt;p&gt;공간 복잡도는 프로그램을 실행시킨 후 그 프로그램이 종료될 때 까지 필요로 하는 자원 공간을 계산합니다. 즉 &lt;strong&gt;메모리 효율&lt;/strong&gt;을 계산하는 것이라 생각하면 편합니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 비교적 자주 쓰이는 시간 복잡도에 대해서만 서술했습니다.&lt;/p&gt;
&lt;p&gt;O(1) ⇒ O(n) ⇒ O(n²) ⇒ O(log n) 순서로 예시를 작성했습니다.&lt;/p&gt;
&lt;h2&gt;일반적인 예시&lt;/h2&gt;
&lt;h3&gt;O(1)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example1(n) {
  return n + n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example1&lt;/em&gt; 은 입력이 1개이며 n의 값에 무관하게 한 번의 연산만 진행합니다. 상수 시간이라고 합니다.&lt;/p&gt;
&lt;h3&gt;O(n)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example2(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    console.log(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example2&lt;/em&gt; 는 입력 n번만큼 반복하여 연산합니다. 선형 시간, 혹은 직선적 시간이라고 합니다.&lt;/p&gt;
&lt;h3&gt;O(n²)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example3(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    console.log(i);
    for (let j = 0; j &amp;#x3C; n; j++) {
      console.log(j);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example3&lt;/em&gt; 는 입력 n의 제곱만큼 연산합니다. 2차 시간이라고 합니다.&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;번외&lt;/em&gt; : O(n³)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example4(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    console.log(i);
    for (let j = 0; j &amp;#x3C; n; j++) {
      console.log(j);
      for (let k = 0; k &amp;#x3C; n; k++) {
        console.log(k);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example4&lt;/em&gt; 는 O(n³), 3차 시간 복잡도의 예&lt;/p&gt;
&lt;h3&gt;O(log n)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example5(n) {
  for (let i = 0; i &amp;#x3C; n; i * 2) {
    console.log(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example5&lt;/em&gt; 는 2의 2승(2²)부터 n승까지의 항목을 출력하는 함수입니다. Big-O 표기법은 &lt;strong&gt;최악&lt;/strong&gt;의 경우를 기준으로 한다는 점을 상기해보면, n 입력 값이 천만이라 가정해도 log₂(10,000,000)은 23.253... 이기 때문에 23번만 값을 출력합니다.&lt;/p&gt;
&lt;h2&gt;Big-O 표기법 규칙&lt;/h2&gt;
&lt;p&gt;개발할 때 위와같은 간단한 반복문만 사용하지는 않습니다. Big-O 표기법에는 더 복잡한 구조의 알고리즘의 시간 복잡도를 계산할 수 있도록 돕는 규칙이 있습니다. 여러가지 규칙이 있지만 이글에선 자주 사용되는 4가지 법칙만 살펴보겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;계수 법칙&lt;/strong&gt; : 상수 제거하기&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;합의 법칙&lt;/strong&gt; : 빅오 더하기&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;곱의 법칙&lt;/strong&gt; : 빅오 곱하기&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다항 법칙&lt;/strong&gt; : 빅오의 k승&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;계수 법칙 &lt;em&gt;상수 제거하기&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Big-O 표기법에선 &lt;strong&gt;입력 크기와 연관되지 않은 상수를 무시&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example6(n) {
  let count = 0;
  for (let i = 0; i &amp;#x3C; n; i++) {
    count += i;
  }
  count *= 100; // 1번 지점
  count /= 100; // 2번 지점
  return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example6&lt;/em&gt; 는 n번만큼 반복한 후 추가로 곱하기(*) 연산과 나누기(/) 연산을 합니다. 여기서 마지막 두번의 연산(1,2번 지점)이 위에서 언급한 &lt;em&gt;상수&lt;/em&gt; 가 됩니다. 1, 2번 지점의 코드가 없다면 &lt;em&gt;example6&lt;/em&gt; 는 &lt;em&gt;f(n) = n&lt;/em&gt; 으로 표현할 수 있습니다. 1, 2번 지점의 코드를 포함한다면 &lt;em&gt;example6&lt;/em&gt; 는 &lt;em&gt;f(n) = n + 2&lt;/em&gt; 로 표현됩니다. 하지만 계수 법칙에 따라 상수를 제거(혹은 제외)함으로 Big-O 표기법으로 표현하면 O(n)이 됩니다.&lt;/p&gt;
&lt;p&gt;이 법칙은 곱셈에서도 유효합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example7(n) {
  let count = 0;
  for( let i = 0; &amp;#x3C; n * 10; i++ ) {
    count += i;
  }
  return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example7&lt;/em&gt; 은 n * 10번 반복하여 연산합니다. 10배라면 꽤 큰 숫자로 보입니다. 하지만 Big-O 표기법은 &lt;strong&gt;최악&lt;/strong&gt;의 경우를 기준으로 한다는 점을 기억해야 합니다. n을 무한대 또는 아주 큰 수라고 생각하면 10배로 연산한다고 해서 크게 달라지는 점은 없습니다. Big-O 표기법은 n(입력값)에 비례하여 알고리즘이 어느정도의 효율성을 보이느냐를 따지는 지표이므로 이와같은 상수는 큰 영향을 주지 못합니다.&lt;/p&gt;
&lt;h3&gt;합의 법칙 &lt;em&gt;빅오 더하기&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;합의 법칙은 &lt;strong&gt;시간 복잡도를 더할 수 있다&lt;/strong&gt;는 것입니다. 두개 이상의 여러 알고리즘을 보유한 상위의 알고리즘이 있고, 이 알고리즘을 Big-O 표기법으로 표현하고 싶을 경우가 있습니다. 합의 법칙은 이런 경우에 적용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example8(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    // 1번 지점
    console.log(i);
  }
  for (let j = 0; j &amp;#x3C; n * 2; j++) {
    // 2번 지점
    console.log(j);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1번 지점은 n번만큼 반복하여 &lt;em&gt;f(n) = n&lt;/em&gt; 입니다. 2번 지점은 n * 2번 반복하여 &lt;em&gt;f(n) = 2n&lt;/em&gt; 입니다. 이를 합하게 되면 &lt;em&gt;f(n) = 6n&lt;/em&gt; 이 됩니다. 이제 여기에 계수 법칙을 적용하게 되면 &lt;em&gt;O(n) = n&lt;/em&gt; 으로 표현할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;곱의 법칙 &lt;em&gt;빅오 곱하기&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;곱의 법칙은 합의 법칙과 마찬가지로 &lt;strong&gt;시간 복잡도를 곱할 수 있다&lt;/strong&gt;는 것입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example9(n) {
  let count = 0;
  for (let i = 0; i &amp;#x3C; n; i++) {
    ++count;
    for (let j = 0; j &amp;#x3C; 2 * n; j++) {
      ++count;
    }
  }
  return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example9&lt;/em&gt; 함수는 &lt;em&gt;f(n) = n * 2n&lt;/em&gt; 입니다. 수식에 따라 시간 복잡도를 곱하게 되면 &lt;em&gt;f(n) = 2n²&lt;/em&gt; 가 되고, 여기에 계수 법칙을 적용하면 최종적으로 &lt;em&gt;O(n) = n²&lt;/em&gt; 로 표현할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;다항 법칙 &lt;em&gt;빅오의 k승&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;다항 법칙은 곱의 법칙과 비슷한 맥락으로 이해할 수 있습니다. 시간 복잡도가 여러개의 항(다항)을 가지고 있을 때 동일한 다항 차수를 지닌 빅오 표기법을 지님을 나타냅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example10(n) {
  let count = 0;
  for (let i = 0; i &amp;#x3C; n * n; i++) {
    ++count;
  }
  return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example10&lt;/em&gt; 함수에서 &lt;em&gt;f(n) = n * n = n²&lt;/em&gt; 입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Javascript - 쓰로틀링(throttling)]]></title><description><![CDATA[…]]></description><link>https://do1con.github.io/post-3-throttling/</link><guid isPermaLink="false">https://do1con.github.io/post-3-throttling/</guid><pubDate>Fri, 01 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;과거에 작성된 글입니다.&lt;/p&gt;
&lt;h2&gt;쓰로틀링이란 무엇인가?&lt;/h2&gt;
&lt;p&gt;쓰로틀링은 주로 이벤트 등에 사용되는 프로그래밍 기법입니다.&lt;/p&gt;
&lt;p&gt;흔히 스크롤 액션 같은 이벤트에 사용됩니다.&lt;/p&gt;
&lt;h2&gt;쓰로틀링의 작동 방식&lt;/h2&gt;
&lt;p&gt;쓰로틀링의 정의를 간단하게 짚고 넘어가겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;함수가 호출된 후 일정 시간동안 함수가 다시 호출되지 않도록 막는 것.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 &lt;strong&gt;일정 시간&lt;/strong&gt;동안 함수 호출을 막는다는 것이 핵심입니다.&lt;/p&gt;
&lt;p&gt;아래와 같은 scroll 이벤트를 봅시다.
box가 scroll 될 때마다 display 속성이 none~block으로 토글되는 이벤트입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let targetState = true;

function eventScroll() {
  const target = document.querySelector(&apos;.box&apos;);
  targetState = !targetState;
  if (targetState) {
    target.style.display = &apos;block&apos;;
  } else {
    target.style.display = &apos;none&apos;;
  }
  console.log(&apos;scroll!!&apos;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/ca7f3fefff89c25f80261ba93d853a51/post-3-1.gif&quot; alt=&quot;show_toggle_event&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;scroll 이벤트가 쉬지 않고 발생한다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;클라이언트 입장에서는 충분히 스크롤을 마구 굴릴 수 있습니다. 이렇게 되면 정성스럽게 짜놓은 이벤트 함수가 고장날 수도 있습니다. (특히 복잡하다면)&lt;/p&gt;
&lt;p&gt;그래서 이런 이벤트에 필요한 기법이 쓰로틀링입니다. 쓰로틀링이란 event 함수를 일정 주기동안 제한하는 기법이라 앞서 언급했습니다.&lt;/p&gt;
&lt;p&gt;위와 같은 상황에선, 스크롤 이벤트가 발생한 후 일정시간동안 scroll이벤트가 다시 발생하지 않도록 제한하는 것이 되겠죠.&lt;/p&gt;
&lt;p&gt;위 코드에 쓰로틀링을 추가해보겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let targetState = true;
let timer;

function eventScroll() {
  if (!timer) {
    timer = setTimeout(() =&gt; {
      const target = document.querySelector(&apos;.box&apos;);
      targetState = !targetState;
      if (targetState) {
        target.style.display = &apos;block&apos;;
      } else {
        target.style.display = &apos;none&apos;;
      }
      console.log(&apos;scroll!!&apos;);
      timer = null;
    }, 1000);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/b44d05a099cf229e8f54a00305e23640/post-3-2.gif&quot; alt=&quot;show_toggle_event2&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;이벤트가 1초에 한 번씩만 작동하고 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;setTimeout 함수를 이용하는 방법입니다. 이벤트가 발생할 때마다 timer에는 수행할 로직이 지정되고, 모든 일을 마친 후 스스로 초기화 합니다. 이 과정에 setTimeout함수가 끼어들어 1000ms라는 딜레이를 부여합니다.&lt;/p&gt;
&lt;p&gt;저는 1000ms로 지정했지만, 딜레이 간격은 얼마든지 수정할 수 있습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React - Error:Maximum update depth... 해결법]]></title><description><![CDATA[과거에 작성된 글입니다. Error: Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or…]]></description><link>https://do1con.github.io/post-2-react-error/</link><guid isPermaLink="false">https://do1con.github.io/post-2-react-error/</guid><pubDate>Tue, 29 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;과거에 작성된 글입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Error: Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;리액트를 처음 접했을 때 접한 에러입니다.&lt;/p&gt;
&lt;p&gt;이 포스트는 해당 에러의 해결법, 발생 원인을 정리한 글입니다.&lt;/p&gt;
&lt;p&gt;이 에러는 onClick과 같은 이벤트에 함수를 잘못 지정할 경우 발생합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;button onClick=&quot;{handleOnClickButton()}&quot;&gt;버튼&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 작성할 경우 에러가 발생합니다.
다시한번 에러 메시지를 봅시다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Maximum update depth exceeded. (최대 업데이트 깊이를 초과했습니다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 컴포넌트가 계속해서 업데이트를 할 것이며, 그 깊이가 무한대에 가깝다는 의미입니다.&lt;/p&gt;
&lt;p&gt;왜 이런일이 발생할까요?&lt;/p&gt;
&lt;p&gt;다시 코드를 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;button onClick=&quot;{handleOnClickButton()}&quot;&gt;버튼&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;onClick 이벤트 발생시 handleOnclickButton 함수를 **&lt;em&gt;실행&lt;/em&gt;**하도록 코드가 작성되어있습니다.&lt;/p&gt;
&lt;p&gt;정말 그럴까요?&lt;/p&gt;
&lt;p&gt;이 코드는 &lt;strong&gt;onClick 이벤트 발생 시 해당 함수를 실행하는게 아닌, 렌더시 해당 함수를 실행시키는 코드&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;즉, 컴포넌트를 렌더하며 함수를 실행 &gt; 함수를 실행 했기때문에 다시 렌더 &gt; 렌더 중 함수 실행문을 만나 다시 함수 실행 &gt; on and on...&lt;/p&gt;
&lt;p&gt;이렇게 무한 루프에 빠지게 됩니다.&lt;/p&gt;
&lt;p&gt;이벤트에 함수를 지정하고 싶으실 땐 아래와 같이 작성해주셔야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;button onClick=&quot;{handleOnClickButton}&quot;&gt;버튼&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;매개변수를 지정해줘야 할경우는 아래와 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;button onClick={() =&gt; handleOnClickButton(...param)}&gt;버튼&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[Javascript - 호이스팅]]></title><description><![CDATA[과거 호이스팅에 대해 공부한 후 정리한 글입니다. 아래의 코드는 어떻게 작동할까요? 일반적인 경우 hey는 if문의 {}영역에서 선언되었으므로 그 밖의 영역에 있는 console.log…]]></description><link>https://do1con.github.io/post-1-hoisting/</link><guid isPermaLink="false">https://do1con.github.io/post-1-hoisting/</guid><pubDate>Mon, 07 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;과거 호이스팅에 대해 공부한 후 정리한 글입니다.&lt;/p&gt;
&lt;h3&gt;아래의 코드는 어떻게 작동할까요?&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;if (true) {
  var hey = &apos;hello&apos;;
}

console.log(hey);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일반적인 경우 hey는 if문의 {}영역에서 선언되었으므로 그 밖의 영역에 있는 console.log에서는 호출될 수 없어야 합니다.&lt;/p&gt;
&lt;p&gt;그러나 자바스크립트는 그렇지 않습다. hey변수가 호이스팅 되었기 때문입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var hey;

if (true) {
  hey = &apos;hello&apos;;
}

console.log(hey);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;호이스팅은 선언과 할당이 분리되는 현상입니다.&lt;/p&gt;
&lt;p&gt;var로 선언된 변수는 function block의 최상단으로 선언이 옮겨집니다.&lt;/p&gt;
&lt;h2&gt;function block의 최상단?&lt;/h2&gt;
&lt;p&gt;var는 function scope라는 특성을 지니고 있습니다.
즉 var의 영역은 function이며 함수 최상단에 선언된다는 의미입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hi() {
  if (true) {
    var say = &apos;hi&apos;;
  }
  console.log(say);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드에서 var say는 function hi에 속해있습니다. 그러므로 런타임에서는&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hi() {
  var say; //선언
  if (true) {
    say = &apos;hi&apos;; // 할당
  }
  console.log(say);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 변경되어 실행됩니다.&lt;/p&gt;
&lt;p&gt;이는 var 변수가 어떤 방식으로 선언되던 상관없이 적용됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function bye() {
  for (var i = 0; i &amp;#x3C; 10; i++) {
    // blah blah
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 반복문에 선언된 변수도 마찬가지 입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function bye() {
  var i; // 선언
  for (i = 0; i &amp;#x3C; 10; i++) {
    // 할당
    // blah blah
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;함수표현식과 호이스팅&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;hi();

var hi = function () {
  console.log(&apos;hi&apos;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 함수 표현식으로 선언하더라도 호이스팅이 적용됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var hi;

hi(); // error! hi 함수에는 아직 함수표현식이 할당되지 않았음

hi = function () {
  console.log(&apos;hi&apos;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;대안은 없을까?&lt;/h2&gt;
&lt;p&gt;호이스팅은 javascript를 유연하게 실행되도록 돕지만, 동시에 기존에 다른 프로그래밍 언어를 공부한 개발자에겐 헷갈리는 요소가 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;때문에, 통상적인 블록스코프를 따르는 변수모델로 let, const가 제시되었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hi() {
  if (true) {
    const say = &apos;hi&apos;;
  }
  console.log(say); // error!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let과 const는 전형적인 block scope를 가졌기 때문에 if문 밖에서 호출될 경우 에러를 발생시킵니다.&lt;/p&gt;
&lt;h2&gt;함수와 호이스팅&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;hi();

function hi() {
  console.log(&apos;hi&apos;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자바스크립트에서는 이런 코드도 실행됩니다. 분명 호출이 선언보다 앞섰는데도 말이죠.&lt;/p&gt;
&lt;p&gt;이런 일이 가능한 이유는 함수도 호이스팅에 적용되기 때문입니다. 함수 선언문은 반드시 최상단으로 끌어 올려집니다.
위 코드는 런타임에선 다음과 같이 실행됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hi() {
  console.log(&apos;hi&apos;);
}

hi();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;함수와 var변수의 호이스팅 우선순위는?&lt;/h2&gt;
&lt;p&gt;간단하게, 변수 호이스팅이 함수 호이스팅보다 먼저 일어납니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;hi();

function hi() {
  var hiMessage = &apos;hi&apos;;
  console.log(message);
}

console.log(byeMessage);

var byeMessage = &apos;bye&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러므로 이 코드는 런타임에서&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var byeMessage;
function hi() {
  var hiMessage;
  hiMessage = &apos;hi&apos;; // 선언과 할당은 분리된다.
  console.log(message); // hi.
}

hi();

byeMessage = &apos;bye&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 해석됩니다.&lt;/p&gt;</content:encoded></item></channel></rss>