<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[do1con blog RSS]]></title><description><![CDATA[do1con의 개발 블로그입니다.]]></description><link>https://do1con.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 07 Nov 2021 01:04:29 GMT</lastBuildDate><item><title><![CDATA[Big-O 표기법 (Big-O Notation)]]></title><description><![CDATA[Big-O 표기법이란? 점근 표기법(asymptotic notation…]]></description><link>https://do1con.github.io/post-4-big-o-notation/</link><guid isPermaLink="false">https://do1con.github.io/post-4-big-o-notation/</guid><pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Big-O 표기법이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;점근 표기법&lt;/strong&gt;(asymptotic notation)&lt;/p&gt;
&lt;p&gt;점근 표기법은 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법입니다. **알고리즘의 복잡도를 단순화(도식화)**할 때나 무한급수의 뒷부분을 간소화할 때 쓰입니다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95&quot;&gt;(위키백과)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Big O 표기법&lt;/em&gt; 은 대표적인 점근 표기법중 하나로 어떠한 알고리즘이 &lt;strong&gt;최악&lt;/strong&gt;의 경우를 기준으로 어느정도의 효율성을 보일 것인가를 예측하는 표기법입니다. 어떤 알고리즘을 f(n)이라 하고, 이를 Big-O 표기법으로 표현하면 O(f(n))으로 표현됩니다.&lt;/p&gt;
&lt;h3&gt;Big-O 복잡도&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1644335aaa8832500767fc4dac43ca78/11a8f/post-4-big-o.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 86.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+ElEQVQ4y3WT7bKaMBCGvf+b6h+np9MO2joc7QH0WAREISQkkA+SbDoKAtppZicD2Tz77u5sFqdTQinDmBBSj1ZV+HzO8/ySZVmapteiqGs6ejEmlLI0yxZVVTnnAMDNltb6IxjWZrO5XK/zO/1HXdMFQqj/BxhORYna/GKUmse7ewez9uYhpB5gSqm1tr/HjnHxc6OFeAR9SmpUJvUDDoJAKdX7DOcSk0HuFZvCTXAYhiOsCBVF+W8j/qv8BNdUlGiuPAbBjfq80FZ2Q80YY8bYbrfrum4Gl4MEDKTsbIp4SWVatU9w0zTb3XaCCZEYj+lZgJKKDLeyM69pY0ziOPZ9X2vd+5oktXoI1EidIE74A3uBy1uGEARTzSw5OwBt7Rm3OeHGaue4NbW1tTVEyVTJ3AEn45CMsGaM559U4jNKmzZ3DoGpwDIHrQMOhmmZKZkAtBP8EQRctM6xPFhF8bFkGJwGd9M3YA2AAdebstZOad9hP9ykbOf//uFv31NRIVVd+PXCr1cx7L0VothWWyzw0O17zc77/sVbfkuCk+6UErJTndXGGqs7rZVWQt2MS6PNS8Nuyqfj0V//ik9/oig6HA7r9frr29tyuVytPM/zoija7/dhGI6vaOo2AAyv4jFJTdMihMoSNU2jVDcfTGOM1hoAMMZ/ASjYzttl2MGBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Big_O_Notation&quot;
        title=&quot;Big_O_Notation&quot;
        src=&quot;/static/1644335aaa8832500767fc4dac43ca78/5a190/post-4-big-o.png&quot;
        srcset=&quot;/static/1644335aaa8832500767fc4dac43ca78/772e8/post-4-big-o.png 200w,
/static/1644335aaa8832500767fc4dac43ca78/e17e5/post-4-big-o.png 400w,
/static/1644335aaa8832500767fc4dac43ca78/5a190/post-4-big-o.png 800w,
/static/1644335aaa8832500767fc4dac43ca78/c1b63/post-4-big-o.png 1200w,
/static/1644335aaa8832500767fc4dac43ca78/11a8f/post-4-big-o.png 1272w&quot;
        sizes=&quot;(max-width: 800px) 100vw, 800px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Big O 로 정의하는 복잡성에는 두가지가 존재합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시간 복잡도&lt;/li&gt;
&lt;li&gt;공간 복잡도&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;시간 복잡도는 대부분의 경우 어떤 알고리즘이 &lt;strong&gt;최악&lt;/strong&gt;의 경우 실행 시간이 어떻게 분포될지를 나타냅니다. 하지만 실행 시간 그 자체를 계산하는 것이 아니라, &lt;strong&gt;연산이 몇 번 이루어지는 가&lt;/strong&gt;를 계산합니다. 거의 대부분의 경우 실행 시간과 비례합니다.&lt;/p&gt;
&lt;p&gt;공간 복잡도는 프로그램을 실행시킨 후 그 프로그램이 종료될 때 까지 필요로 하는 자원 공간을 계산합니다. 즉 &lt;strong&gt;메모리 효율&lt;/strong&gt;을 계산하는 것이라 생각하면 편합니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 비교적 자주 쓰이는 시간 복잡도에 대해서만 서술했습니다.&lt;/p&gt;
&lt;p&gt;O(1) ⇒ O(n) ⇒ O(n²) ⇒ O(log n) 순서로 예시를 작성했습니다.&lt;/p&gt;
&lt;h2&gt;일반적인 예시&lt;/h2&gt;
&lt;h3&gt;O(1)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example1(n) {
  return n + n;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example1&lt;/em&gt; 은 입력이 1개이며 n의 값에 무관하게 한 번의 연산만 진행합니다. 상수 시간이라고 합니다.&lt;/p&gt;
&lt;h3&gt;O(n)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example2(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    console.log(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example2&lt;/em&gt; 는 입력 n번만큼 반복하여 연산합니다. 선형 시간, 혹은 직선적 시간이라고 합니다.&lt;/p&gt;
&lt;h3&gt;O(n²)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example3(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    console.log(i);
    for (let j = 0; j &amp;#x3C; n; j++) {
      console.log(j);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example3&lt;/em&gt; 는 입력 n의 제곱만큼 연산합니다. 2차 시간이라고 합니다.&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;번외&lt;/em&gt; : O(n³)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example4(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    console.log(i);
    for (let j = 0; j &amp;#x3C; n; j++) {
      console.log(j);
      for (let k = 0; k &amp;#x3C; n; k++) {
        console.log(k);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example4&lt;/em&gt; 는 O(n³), 3차 시간 복잡도의 예&lt;/p&gt;
&lt;h3&gt;O(log n)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example5(n) {
  for (let i = 0; i &amp;#x3C; n; i * 2) {
    console.log(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example5&lt;/em&gt; 는 2의 2승(2²)부터 n승까지의 항목을 출력하는 함수입니다. Big-O 표기법은 &lt;strong&gt;최악&lt;/strong&gt;의 경우를 기준으로 한다는 점을 상기해보면, n 입력 값이 천만이라 가정해도 log₂(10,000,000)은 23.253... 이기 때문에 23번만 값을 출력합니다.&lt;/p&gt;
&lt;h2&gt;Big-O 표기법 규칙&lt;/h2&gt;
&lt;p&gt;개발할 때 위와같은 간단한 반복문만 사용하지는 않습니다. Big-O 표기법에는 더 복잡한 구조의 알고리즘의 시간 복잡도를 계산할 수 있도록 돕는 규칙이 있습니다. 여러가지 규칙이 있지만 이글에선 자주 사용되는 4가지 법칙만 살펴보겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;계수 법칙&lt;/strong&gt; : 상수 제거하기&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;합의 법칙&lt;/strong&gt; : 빅오 더하기&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;곱의 법칙&lt;/strong&gt; : 빅오 곱하기&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다항 법칙&lt;/strong&gt; : 빅오의 k승&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;계수 법칙 &lt;em&gt;상수 제거하기&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Big-O 표기법에선 &lt;strong&gt;입력 크기와 연관되지 않은 상수를 무시&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example6(n) {
  let count = 0;
  for (let i = 0; i &amp;#x3C; n; i++) {
    count += i;
  }
  count *= 100; // 1번 지점
  count /= 100; // 2번 지점
  return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example6&lt;/em&gt; 는 n번만큼 반복한 후 추가로 곱하기(*) 연산과 나누기(/) 연산을 합니다. 여기서 마지막 두번의 연산(1,2번 지점)이 위에서 언급한 &lt;em&gt;상수&lt;/em&gt; 가 됩니다. 1, 2번 지점의 코드가 없다면 &lt;em&gt;example6&lt;/em&gt; 는 &lt;em&gt;f(n) = n&lt;/em&gt; 으로 표현할 수 있습니다. 1, 2번 지점의 코드를 포함한다면 &lt;em&gt;example6&lt;/em&gt; 는 &lt;em&gt;f(n) = n + 2&lt;/em&gt; 로 표현됩니다. 하지만 계수 법칙에 따라 상수를 제거(혹은 제외)함으로 Big-O 표기법으로 표현하면 O(n)이 됩니다.&lt;/p&gt;
&lt;p&gt;이 법칙은 곱셈에서도 유효합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example7(n) {
  let count = 0;
  for( let i = 0; &amp;#x3C; n * 10; i++ ) {
    count += i;
  }
  return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example7&lt;/em&gt; 은 n * 10번 반복하여 연산합니다. 10배라면 꽤 큰 숫자로 보입니다. 하지만 Big-O 표기법은 &lt;strong&gt;최악&lt;/strong&gt;의 경우를 기준으로 한다는 점을 기억해야 합니다. n을 무한대 또는 아주 큰 수라고 생각하면 10배로 연산한다고 해서 크게 달라지는 점은 없습니다. Big-O 표기법은 n(입력값)에 비례하여 알고리즘이 어느정도의 효율성을 보이느냐를 따지는 지표이므로 이와같은 상수는 큰 영향을 주지 못합니다.&lt;/p&gt;
&lt;h3&gt;합의 법칙 &lt;em&gt;빅오 더하기&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;합의 법칙은 &lt;strong&gt;시간 복잡도를 더할 수 있다&lt;/strong&gt;는 것입니다. 두개 이상의 여러 알고리즘을 보유한 상위의 알고리즘이 있고, 이 알고리즘을 Big-O 표기법으로 표현하고 싶을 경우가 있습니다. 합의 법칙은 이런 경우에 적용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example8(n) {
  for (let i = 0; i &amp;#x3C; n; i++) {
    // 1번 지점
    console.log(i);
  }
  for (let j = 0; j &amp;#x3C; n * 2; j++) {
    // 2번 지점
    console.log(j);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1번 지점은 n번만큼 반복하여 &lt;em&gt;f(n) = n&lt;/em&gt; 입니다. 2번 지점은 n * 2번 반복하여 &lt;em&gt;f(n) = 2n&lt;/em&gt; 입니다. 이를 합하게 되면 &lt;em&gt;f(n) = 6n&lt;/em&gt; 이 됩니다. 이제 여기에 계수 법칙을 적용하게 되면 &lt;em&gt;O(n) = n&lt;/em&gt; 으로 표현할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;곱의 법칙 &lt;em&gt;빅오 곱하기&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;곱의 법칙은 합의 법칙과 마찬가지로 &lt;strong&gt;시간 복잡도를 곱할 수 있다&lt;/strong&gt;는 것입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example9(n) {
  let count = 0;
  for (let i = 0; i &amp;#x3C; n; i++) {
    ++count;
    for (let j = 0; j &amp;#x3C; 2 * n; j++) {
      ++count;
    }
  }
  return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example9&lt;/em&gt; 함수는 &lt;em&gt;f(n) = n * 2n&lt;/em&gt; 입니다. 수식에 따라 시간 복잡도를 곱하게 되면 &lt;em&gt;f(n) = 2n²&lt;/em&gt; 가 되고, 여기에 계수 법칙을 적용하면 최종적으로 &lt;em&gt;O(n) = n²&lt;/em&gt; 로 표현할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;다항 법칙 &lt;em&gt;빅오의 k승&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;다항 법칙은 곱의 법칙과 비슷한 맥락으로 이해할 수 있습니다. 시간 복잡도가 여러개의 항(다항)을 가지고 있을 때 동일한 다항 차수를 지닌 빅오 표기법을 지님을 나타냅니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function example10(n) {
  let count = 0;
  for (let i = 0; i &amp;#x3C; n * n; i++) {
    ++count;
  }
  return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;example10&lt;/em&gt; 함수에서 &lt;em&gt;f(n) = n * n = n²&lt;/em&gt; 입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Javascript - 쓰로틀링(throttling)]]></title><description><![CDATA[…]]></description><link>https://do1con.github.io/post-3-throttling/</link><guid isPermaLink="false">https://do1con.github.io/post-3-throttling/</guid><pubDate>Fri, 01 Nov 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;과거에 작성된 글입니다.&lt;/p&gt;
&lt;h2&gt;쓰로틀링이란 무엇인가?&lt;/h2&gt;
&lt;p&gt;쓰로틀링은 주로 이벤트 등에 사용되는 프로그래밍 기법입니다.&lt;/p&gt;
&lt;p&gt;흔히 스크롤 액션 같은 이벤트에 사용됩니다.&lt;/p&gt;
&lt;h2&gt;쓰로틀링의 작동 방식&lt;/h2&gt;
&lt;p&gt;쓰로틀링의 정의를 간단하게 짚고 넘어가겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;함수가 호출된 후 일정 시간동안 함수가 다시 호출되지 않도록 막는 것.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 &lt;strong&gt;일정 시간&lt;/strong&gt;동안 함수 호출을 막는다는 것이 핵심입니다.&lt;/p&gt;
&lt;p&gt;아래와 같은 scroll 이벤트를 봅시다.
box가 scroll 될 때마다 display 속성이 none~block으로 토글되는 이벤트입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let targetState = true;

function eventScroll() {
  const target = document.querySelector(&apos;.box&apos;);
  targetState = !targetState;
  if (targetState) {
    target.style.display = &apos;block&apos;;
  } else {
    target.style.display = &apos;none&apos;;
  }
  console.log(&apos;scroll!!&apos;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/ca7f3fefff89c25f80261ba93d853a51/post-3-1.gif&quot; alt=&quot;show_toggle_event&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;scroll 이벤트가 쉬지 않고 발생한다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;클라이언트 입장에서는 충분히 스크롤을 마구 굴릴 수 있습니다. 이렇게 되면 정성스럽게 짜놓은 이벤트 함수가 고장날 수도 있습니다. (특히 복잡하다면)&lt;/p&gt;
&lt;p&gt;그래서 이런 이벤트에 필요한 기법이 쓰로틀링입니다. 쓰로틀링이란 event 함수를 일정 주기동안 제한하는 기법이라 앞서 언급했습니다.&lt;/p&gt;
&lt;p&gt;위와 같은 상황에선, 스크롤 이벤트가 발생한 후 일정시간동안 scroll이벤트가 다시 발생하지 않도록 제한하는 것이 되겠죠.&lt;/p&gt;
&lt;p&gt;위 코드에 쓰로틀링을 추가해보겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let targetState = true;
let timer;

function eventScroll() {
  if (!timer) {
    timer = setTimeout(() =&gt; {
      const target = document.querySelector(&apos;.box&apos;);
      targetState = !targetState;
      if (targetState) {
        target.style.display = &apos;block&apos;;
      } else {
        target.style.display = &apos;none&apos;;
      }
      console.log(&apos;scroll!!&apos;);
      timer = null;
    }, 1000);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/b44d05a099cf229e8f54a00305e23640/post-3-2.gif&quot; alt=&quot;show_toggle_event2&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;이벤트가 1초에 한 번씩만 작동하고 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;setTimeout 함수를 이용하는 방법입니다. 이벤트가 발생할 때마다 timer에는 수행할 로직이 지정되고, 모든 일을 마친 후 스스로 초기화 합니다. 이 과정에 setTimeout함수가 끼어들어 1000ms라는 딜레이를 부여합니다.&lt;/p&gt;
&lt;p&gt;저는 1000ms로 지정했지만, 딜레이 간격은 얼마든지 수정할 수 있습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React - Error:Maximum update depth... 해결법]]></title><description><![CDATA[과거에 작성된 글입니다. Error: Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or…]]></description><link>https://do1con.github.io/post-2-react-error/</link><guid isPermaLink="false">https://do1con.github.io/post-2-react-error/</guid><pubDate>Tue, 29 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;과거에 작성된 글입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Error: Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;리액트를 처음 접했을 때 접한 에러입니다.&lt;/p&gt;
&lt;p&gt;이 포스트는 해당 에러의 해결법, 발생 원인을 정리한 글입니다.&lt;/p&gt;
&lt;p&gt;이 에러는 onClick과 같은 이벤트에 함수를 잘못 지정할 경우 발생합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;button onClick=&quot;{handleOnClickButton()}&quot;&gt;버튼&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 작성할 경우 에러가 발생합니다.
다시한번 에러 메시지를 봅시다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Maximum update depth exceeded. (최대 업데이트 깊이를 초과했습니다.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 컴포넌트가 계속해서 업데이트를 할 것이며, 그 깊이가 무한대에 가깝다는 의미입니다.&lt;/p&gt;
&lt;p&gt;왜 이런일이 발생할까요?&lt;/p&gt;
&lt;p&gt;다시 코드를 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;button onClick=&quot;{handleOnClickButton()}&quot;&gt;버튼&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;onClick 이벤트 발생시 handleOnclickButton 함수를 **&lt;em&gt;실행&lt;/em&gt;**하도록 코드가 작성되어있습니다.&lt;/p&gt;
&lt;p&gt;정말 그럴까요?&lt;/p&gt;
&lt;p&gt;이 코드는 &lt;strong&gt;onClick 이벤트 발생 시 해당 함수를 실행하는게 아닌, 렌더시 해당 함수를 실행시키는 코드&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;즉, 컴포넌트를 렌더하며 함수를 실행 &gt; 함수를 실행 했기때문에 다시 렌더 &gt; 렌더 중 함수 실행문을 만나 다시 함수 실행 &gt; on and on...&lt;/p&gt;
&lt;p&gt;이렇게 무한 루프에 빠지게 됩니다.&lt;/p&gt;
&lt;p&gt;이벤트에 함수를 지정하고 싶으실 땐 아래와 같이 작성해주셔야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;button onClick=&quot;{handleOnClickButton}&quot;&gt;버튼&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;매개변수를 지정해줘야 할경우는 아래와 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;button onClick={() =&gt; handleOnClickButton(...param)}&gt;버튼&amp;#x3C;/button&gt;
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[Javascript - 호이스팅]]></title><description><![CDATA[과거 호이스팅에 대해 공부한 후 정리한 글입니다. 아래의 코드는 어떻게 작동할까요? 일반적인 경우 hey는 if문의 {}영역에서 선언되었으므로 그 밖의 영역에 있는 console.log…]]></description><link>https://do1con.github.io/post-1-hoisting/</link><guid isPermaLink="false">https://do1con.github.io/post-1-hoisting/</guid><pubDate>Mon, 07 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;과거 호이스팅에 대해 공부한 후 정리한 글입니다.&lt;/p&gt;
&lt;h3&gt;아래의 코드는 어떻게 작동할까요?&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;if (true) {
  var hey = &apos;hello&apos;;
}

console.log(hey);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일반적인 경우 hey는 if문의 {}영역에서 선언되었으므로 그 밖의 영역에 있는 console.log에서는 호출될 수 없어야 합니다.&lt;/p&gt;
&lt;p&gt;그러나 자바스크립트는 그렇지 않습다. hey변수가 호이스팅 되었기 때문입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var hey;

if (true) {
  hey = &apos;hello&apos;;
}

console.log(hey);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;호이스팅은 선언과 할당이 분리되는 현상입니다.&lt;/p&gt;
&lt;p&gt;var로 선언된 변수는 function block의 최상단으로 선언이 옮겨집니다.&lt;/p&gt;
&lt;h2&gt;function block의 최상단?&lt;/h2&gt;
&lt;p&gt;var는 function scope라는 특성을 지니고 있습니다.
즉 var의 영역은 function이며 함수 최상단에 선언된다는 의미입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hi() {
  if (true) {
    var say = &apos;hi&apos;;
  }
  console.log(say);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드에서 var say는 function hi에 속해있습니다. 그러므로 런타임에서는&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hi() {
  var say; //선언
  if (true) {
    say = &apos;hi&apos;; // 할당
  }
  console.log(say);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 변경되어 실행됩니다.&lt;/p&gt;
&lt;p&gt;이는 var 변수가 어떤 방식으로 선언되던 상관없이 적용됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function bye() {
  for (var i = 0; i &amp;#x3C; 10; i++) {
    // blah blah
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 반복문에 선언된 변수도 마찬가지 입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function bye() {
  var i; // 선언
  for (i = 0; i &amp;#x3C; 10; i++) {
    // 할당
    // blah blah
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;함수표현식과 호이스팅&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;hi();

var hi = function () {
  console.log(&apos;hi&apos;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 함수 표현식으로 선언하더라도 호이스팅이 적용됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var hi;

hi(); // error! hi 함수에는 아직 함수표현식이 할당되지 않았음

hi = function () {
  console.log(&apos;hi&apos;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;대안은 없을까?&lt;/h2&gt;
&lt;p&gt;호이스팅은 javascript를 유연하게 실행되도록 돕지만, 동시에 기존에 다른 프로그래밍 언어를 공부한 개발자에겐 헷갈리는 요소가 될 수 있습니다.&lt;/p&gt;
&lt;p&gt;때문에, 통상적인 블록스코프를 따르는 변수모델로 let, const가 제시되었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hi() {
  if (true) {
    const say = &apos;hi&apos;;
  }
  console.log(say); // error!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;let과 const는 전형적인 block scope를 가졌기 때문에 if문 밖에서 호출될 경우 에러를 발생시킵니다.&lt;/p&gt;
&lt;h2&gt;함수와 호이스팅&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;hi();

function hi() {
  console.log(&apos;hi&apos;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자바스크립트에서는 이런 코드도 실행됩니다. 분명 호출이 선언보다 앞섰는데도 말이죠.&lt;/p&gt;
&lt;p&gt;이런 일이 가능한 이유는 함수도 호이스팅에 적용되기 때문입니다. 함수 선언문은 반드시 최상단으로 끌어 올려집니다.
위 코드는 런타임에선 다음과 같이 실행됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hi() {
  console.log(&apos;hi&apos;);
}

hi();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;함수와 var변수의 호이스팅 우선순위는?&lt;/h2&gt;
&lt;p&gt;간단하게, 변수 호이스팅이 함수 호이스팅보다 먼저 일어납니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;hi();

function hi() {
  var hiMessage = &apos;hi&apos;;
  console.log(message);
}

console.log(byeMessage);

var byeMessage = &apos;bye&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러므로 이 코드는 런타임에서&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var byeMessage;
function hi() {
  var hiMessage;
  hiMessage = &apos;hi&apos;; // 선언과 할당은 분리된다.
  console.log(message); // hi.
}

hi();

byeMessage = &apos;bye&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 해석됩니다.&lt;/p&gt;</content:encoded></item></channel></rss>